===========================================
syntax_v2.syn – Full Python Browser IDE API
===========================================

This file is a **complete reference** for the Python Browser IDE:

- Virtual Desktop window API (`js_bridge`)
- Drawing and animation
- Keyboard & mouse input
- Pyodide + JS interop basics
- Pygame compatibility layer (VDG backend)
- Screenshots / image backgrounds
- Best practices for proxies, loops, and cleanup

Copy any example into a `.py` file in the IDE and press ▶ Run.


 
 
===========================================
0. QUICK START – 3 TINY PROGRAMS
===========================================

-------------------------------------------
0.1 Minimal Virtual Desktop window
-------------------------------------------

    import js

    def main():
        js_bridge = js.window.js_bridge

        win = js_bridge.create_window("Hello Window", 400, 250)

        win.clear()
        win.draw_text(40, 80, "Hello from Python!", "white", "24px Arial")

    main()

What you get:

- A Virtual Desktop window titled “Hello Window”
- Text at (40, 80) drawn in white.


 
-------------------------------------------
0.2 Minimal Virtual Desktop “app layout”
-------------------------------------------

    import js

    def main():
        js_bridge = js.window.js_bridge
        win = js_bridge.create_window("App Layout", 600, 360)

        win.clear()

        # Background
        win.fill_rect(0, 0, 600, 360, "#1e1e1e")

        # Top bar
        win.fill_rect(0, 0, 600, 40, "#333333")
        win.draw_text(12, 26, "My Tool", "white", "18px 'Segoe UI'")

        # Sidebar
        win.fill_rect(0, 40, 160, 320, "#252526")
        win.draw_text(12, 70, "Sidebar", "#cccccc", "14px 'Segoe UI'")

        # Content area
        win.fill_rect(160, 40, 440, 320, "#1e1e1e")
        win.draw_text(180, 70, "Main Content", "#ffffff", "16px 'Segoe UI'")

    main()


 
-------------------------------------------
0.3 Minimal pygame-style window (VDG backend)
-------------------------------------------

In this IDE, pygame is **emulated** and routed into the Virtual Desktop via
`enable_pygame_vdg`. A simple, supported subset is available:

    import pygame
    import time

    def main():
        # Note: pygame.init() and set_caption() are NOT required here
        screen = pygame.display.set_mode((400, 300))
        clock = pygame.time.Clock()

        for i in range(120):
            # Fill background
            screen.fill((0, 0, 64))

            # Moving “player”
            x = 20 + i * 2
            pygame.draw.rect(screen, (0, 255, 0), (x, 120, 40, 40))

            # Flip is a no-op but allowed
            pygame.display.flip()

            clock.tick(30)  # ~30 FPS
            time.sleep(0.01)

    if __name__ == "__main__":
        main()

Notes:

- Supported:
  - `pygame.display.set_mode((w, h))`
  - `pygame.display.flip()`
  - `screen.fill(color)`
  - `pygame.draw.rect(screen, color, (x, y, w, h))`
  - `pygame.time.Clock().tick(fps)`
- Not implemented in this environment:
  - `pygame.init()`
  - `pygame.display.set_caption()`
  - `pygame.event.get()`, surfaces, audio, etc.

Just treat it as a “pygame-flavored” drawing API on top of the Virtual Desktop.


 
 
===========================================
1. ENVIRONMENT OVERVIEW
===========================================

1.1 Where your Python runs

- Your Python code runs in **Pyodide** (Python compiled to WebAssembly).
- `print()` writes to the **Terminal** panel at the bottom of the IDE.
- Exceptions appear in the Terminal and sometimes the browser console.

1.2 Files and the virtual filesystem

- The IDE stores files in `localStorage`.
- On Run:
  - The IDE mirrors all non-folder keys into Pyodide’s filesystem.
  - Each file key is written as a file with that name.

Important details:

- Plain text (e.g., `.py`, `.txt`) is written as Unicode text.
- **Images (new behavior):**
  - When imported via the IDE’s “Import File/Folder/Zip”:
    - The IDE **may store them as Data URLs**:
      - `data:image/png;base64,AAA...`
    - In that case, from Python they are **text files** containing a Data URL.
  - Binary images coming from zipped projects might still be raw bytes.

You can check by opening a file in Python:

    with open("screenshot.png", "rb") as f:
        head = f.read(16)
    print(head)

If it starts with `b'data:image'`, it’s a Data URL string. If it starts with `b'\x89PNG\r\n\x1a\n'`, it’s a real PNG.

1.3 Accessing the browser from Python

- `import js` gives you access to the JavaScript world.
- Common objects:
  - `js.window`    – top-level browser window
  - `js.document`  – the DOM document
  - `js.console`   – browser console
- IDE-specific:
  - `js.window.js_bridge` – Virtual Desktop / window API
  - `js.window.logDebug(msg, type)` – writes to IDE Logs panel
  - `js.installPackage(name)` – adds a package to `<py-config>` (for next reload)
  - The IDE already sets `builtins.input = custom_input` which can trigger
    `pip install` calls too.


 
 
===========================================
2. VIRTUAL DESKTOP WINDOW API
===========================================

2.1 Creating a window

Syntax:

    win = js_bridge.create_window(title: str, width: int, height: int)

- `title`  – window title bar text
- `width`  – initial drawing width in pixels
- `height` – initial drawing height in pixels

Returns an object `win` with:

- `win.id`           – DOM id of the window container (`<div id="...">`)
- `win.fill_rect(x, y, w, h, color)` – fill rectangle
- `win.draw_text(x, y, text, color, font)` – draw text
- `win.clear()`      – clear canvas
- `win.close()`      – close this window

Example:

    import js

    def main():
        js_bridge = js.window.js_bridge
        win = js_bridge.create_window("Stats", 320, 180)

        win.clear()
        win.fill_rect(0, 0, 320, 180, "#1e1e1e")
        win.draw_text(10, 30, "Hello, stats window!", "white", "16px 'Segoe UI'")

    main()


 
2.2 Multiple windows

    import js

    def main():
        js_bridge = js.window.js_bridge

        main_win = js_bridge.create_window("Main", 400, 250)
        log_win  = js_bridge.create_window("Log",  360, 220)

        main_win.clear()
        main_win.fill_rect(0, 0, 400, 250, "#202020")
        main_win.draw_text(20, 40, "Main Window", "white", "18px 'Segoe UI'")

        log_win.clear()
        log_win.fill_rect(0, 0, 360, 220, "#111111")
        log_win.draw_text(10, 25, "Log Output", "#75beff", "14px monospace")

    main()


 
2.3 Closing windows from Python

    import js, time

    def main():
        js_bridge = js.window.js_bridge
        win = js_bridge.create_window("Temporary", 320, 160)

        win.clear()
        win.draw_text(10, 60, "Closing in 2 seconds...", "white", "16px Arial")
        time.sleep(2)
        win.close()
        print("Window closed.")

    main()


 
 
===========================================
3. DRAWING DETAILS
===========================================

3.1 Coordinate system

- `(0, 0)` is the **top-left** of the canvas.
- `x` increases to the right, `y` increases downward.
- Units are **pixels**.

3.2 Colors

Anything the browser understands as a CSS color:

- Named: `"red"`, `"cyan"`, `"white"`
- Hex: `"#ff0000"`, `"#00ffcc"`, `"#202020"`
- RGB: `"rgb(255, 0, 0)"`, `"rgb(30, 30, 30)"`

3.3 `win.clear()`

Clears the entire canvas:

    win.clear()
    win.draw_text(10, 30, "After clear()", "white", "16px Arial")

3.4 `win.fill_rect(x, y, w, h, color)`

    win.fill_rect(0, 0, 500, 300, "#1e1e1e")   # background
    win.fill_rect(0, 0, 500, 40, "#333333")    # top bar
    win.fill_rect(0, 40, 120, 260, "#252526")  # sidebar

Useful to build basic UI layout, progress bars, health bars, etc.

3.5 `win.draw_text(x, y, text, color, font)`

    win.draw_text(20, 30, "Title", "white", "18px 'Segoe UI'")
    win.draw_text(20, 60, "FPS: 60", "#00ff00", "14px monospace")

- `(x, y)` is roughly the baseline left of the text.
- `font` is a CSS font descriptor: `"14px monospace"`, `"20px 'Segoe UI'"`, etc.

Example status bar:

    win.fill_rect(0, 180, 320, 20, "#333333")
    win.draw_text(8, 195, "Status: OK", "#75beff", "12px monospace")


 
 
===========================================
4. ACCESSING THE UNDERLYING CANVAS & RESIZING
===========================================

4.1 Getting the `<canvas>` and DOM element

Each `win` has:

- `win.id` – DOM id of the outer window `<div>`

From Python:

    import js

    def main():
        js_bridge = js.window.js_bridge
        win = js_bridge.create_window("Canvas Info", 400, 300)

        win_el = js.document.getElementById(win.id)
        canvas = win_el.querySelector("canvas")

        width  = canvas.width
        height = canvas.height

        win.clear()
        win.fill_rect(0, 0, width, height, "#202020")
        win.draw_text(10, 30, f"Canvas: {width} x {height}", "white", "16px monospace")

    main()


 
4.2 Handling window resizing

The Virtual Desktop allows resizing windows. The IDE keeps the `<canvas>` size
in sync with the window. For smooth behavior:

- Always recompute `canvas.width` / `canvas.height` each frame.
- Redraw based on your game/app state, not previous pixels.

Example – dynamic background color that depends on size:

    import js
    from js import document
    from pyodide.ffi import create_proxy

    WIDTH, HEIGHT = 400, 300

    _draw_proxy = None

    def main():
        js_bridge = js.window.js_bridge
        win = js_bridge.create_window("Resizing Example", WIDTH, HEIGHT)

        win_el = document.getElementById(win.id)
        canvas = win_el.querySelector("canvas")
        ctx = canvas.getContext("2d")

        def draw(*_args):
            w = int(canvas.width)
            h = int(canvas.height)
            if w <= 0 or h <= 0:
                return

            # Gradient-ish effect just using rects
            ctx.clearRect(0, 0, w, h)
            ctx.fillStyle = "#202020"
            ctx.fillRect(0, 0, w, h)
            ctx.fillStyle = "#007acc"
            ctx.fillRect(0, 0, w, 30)
            ctx.fillStyle = "#333333"
            ctx.fillRect(0, h - 24, w, 24)

        global _draw_proxy
        _draw_proxy = create_proxy(draw)
        js.window.setInterval(_draw_proxy, 100)

        draw()

    main()


 
 
===========================================
5. ANIMATION & GAME LOOPS
===========================================

There are two main patterns:

- Python loops with `time.sleep` (simple, blocking).
- JS timers with `setInterval` + `create_proxy` (non-blocking, modern).

-------------------------------------------
5.1 Simple Python loop with time.sleep
-------------------------------------------

Good for short demos, less ideal for heavy UIs.

    import js
    import time

    WIDTH, HEIGHT = 400, 200

    def main():
        js_bridge = js.window.js_bridge
        win = js_bridge.create_window("Simple Animation", WIDTH, HEIGHT)

        for i in range(40):
            win.clear()
            win.fill_rect(0, 0, WIDTH, HEIGHT, "#000000")

            x = 10 + i * 8
            win.fill_rect(x, 80, 40, 40, "#00ffcc")

            win.draw_text(10, 30, f"Frame {i+1}", "white", "16px monospace")
            time.sleep(0.1)

    main()


 
-------------------------------------------
5.2 Smooth loops with setInterval + create_proxy
-------------------------------------------

For continuous games and tools, prefer:

- `pyodide.ffi.create_proxy` to wrap Python callbacks.
- `js.window.setInterval(proxy, interval_ms)` to schedule them.

Important:

- **You MUST keep proxies alive** (store them somewhere like `js.window`) or
  Pyodide will garbage-collect them. Then you get errors like:
  “This borrowed proxy was automatically destroyed at the end of a function call”.

Example – bouncing ball:

    import js
    from pyodide.ffi import create_proxy

    WIDTH = 400
    HEIGHT = 250

    _step_proxy = None

    def main():
        js_bridge = js.window.js_bridge
        win = js_bridge.create_window("Bouncing Ball", WIDTH, HEIGHT)

        state = {
            "x": WIDTH // 2,
            "y": HEIGHT // 2,
            "vx": 3,
            "vy": 2,
            "r": 15,
        }

        def draw():
            win.clear()
            win.fill_rect(0, 0, WIDTH, HEIGHT, "#101010")

            x = state["x"] - state["r"]
            y = state["y"] - state["r"]
            size = state["r"] * 2
            win.fill_rect(x, y, size, size, "#ff5555")

        def step(*_args):
            state["x"] += state["vx"]
            state["y"] += state["vy"]

            if state["x"] - state["r"] < 0 or state["x"] + state["r"] > WIDTH:
                state["vx"] *= -1
            if state["y"] - state["r"] < 0 or state["y"] + state["r"] > HEIGHT:
                state["vy"] *= -1

            draw()

        global _step_proxy
        _step_proxy = create_proxy(step)
        js.window._bouncing_ball_step_proxy = _step_proxy  # keep it alive

        interval_id = js.window.setInterval(_step_proxy, 16)

        def cleanup():
            js.window.clearInterval(interval_id)
            try:
                del js.window._bouncing_ball_step_proxy
            except Exception:
                pass

        js.window._bouncing_ball_cleanup = cleanup

        draw()
        print("Bouncing ball started.")

    main()


 
 
===========================================
6. KEYBOARD & MOUSE INPUT
===========================================

Use browser events via `js.document.addEventListener` plus `create_proxy`.

-------------------------------------------
6.1 Keyboard movement example
-------------------------------------------

Move a square with Arrow keys or WASD:

    import js
    from pyodide.ffi import create_proxy

    WIDTH, HEIGHT = 400, 250

    _kb_proxy = None

    def main():
        js_bridge = js.window.js_bridge
        win = js_bridge.create_window("Keyboard Move", WIDTH, HEIGHT)

        state = {
            "x": WIDTH // 2,
            "y": HEIGHT // 2,
            "speed": 10,
        }

        def redraw():
            win.clear()
            win.fill_rect(0, 0, WIDTH, HEIGHT, "#000000")
            win.fill_rect(state["x"], state["y"], 30, 30, "#00ff00")
            win.draw_text(10, 20, "Use Arrow keys or WASD", "white", "14px monospace")

        def on_key_down(event):
            key = event.key
            if key in ("ArrowUp", "w", "W"):
                state["y"] -= state["speed"]
            elif key in ("ArrowDown", "s", "S"):
                state["y"] += state["speed"]
            elif key in ("ArrowLeft", "a", "A"):
                state["x"] -= state["speed"]
            elif key in ("ArrowRight", "d", "D"):
                state["x"] += state["speed"]

            redraw()

        global _kb_proxy
        _kb_proxy = create_proxy(on_key_down)
        js.document.addEventListener("keydown", _kb_proxy)
        js.window._kb_move_proxy = _kb_proxy  # keep alive

        redraw()
        print("Keyboard-controlled square ready.")

    main()


 
-------------------------------------------
6.2 Mouse tracking over a specific window
-------------------------------------------

Track mouse coordinates relative to a particular window’s canvas:

    import js
    from js import document
    from pyodide.ffi import create_proxy

    _mouse_proxies = None

    def main():
        js_bridge = js.window.js_bridge
        win = js_bridge.create_window("Mouse Tracker", 500, 200)
        win_id = win.id

        win_el = document.getElementById(win_id)
        canvas = win_el.querySelector("canvas")

        state = {"x": 0, "y": 0}

        def redraw():
            win.clear()
            win.fill_rect(0, 0, canvas.width, canvas.height, "#202020")
            win.draw_text(
                20, 60,
                f"Mouse: {state['x']}, {state['y']}",
                "white",
                "18px monospace",
            )

        def on_mouse_move(event):
            rect = canvas.getBoundingClientRect()
            state["x"] = int(event.clientX - rect.left)
            state["y"] = int(event.clientY - rect.top)
            redraw()

        mouse_proxy = create_proxy(on_mouse_move)
        js.document.addEventListener("mousemove", mouse_proxy)

        global _mouse_proxies
        _mouse_proxies = [mouse_proxy]
        js.window._mouse_tracker_proxies = _mouse_proxies

        redraw()
        print("Move your mouse over the 'Mouse Tracker' window.")

    main()


 
 
===========================================
7. PYGAME COMPATIBILITY LAYER (VDG)
===========================================

The IDE provides a lightweight pygame-like environment mapped to the Virtual Desktop.

7.1 What is implemented

When your code runs, the IDE calls `enable_pygame_vdg()`, which:

- Creates (or patches) a `pygame` module with:
  - `pygame.display.set_mode((w, h))` → creates a Virtual Desktop window
  - `pygame.display.flip()` → no-op (drawing is immediate)
  - A surface object returned by `set_mode` with:
    - `surface.fill(color)` → fills the VDG window
  - `pygame.draw.rect(surface, color, (x, y, w, h), width=0)` → draws rects
  - `pygame.time.Clock().tick(fps)` → simple sleep-based ticker

7.2 What is NOT implemented

- `pygame.init()`
- `pygame.display.set_caption()`
- `pygame.event.get()`, `pygame.event.poll()`, etc.
- Additional surfaces, image loading, fonts, audio, etc.

Use it as a convenient syntax layer on top of VDG, not full pygame.

7.3 Basic pygame-style example

    import pygame
    import time

    def main():
        screen = pygame.display.set_mode((400, 300))
        clock = pygame.time.Clock()

        for frame in range(120):
            screen.fill((10, 10, 30))
            x = 20 + frame * 2
            pygame.draw.rect(screen, (0, 200, 80), (x, 120, 40, 40))
            pygame.display.flip()

            clock.tick(30)
            time.sleep(0.01)

        print("Done.")

    if __name__ == "__main__":
        main()

7.4 Using VDG + pygame for UI layout

    import pygame
    import time

    def main():
        screen = pygame.display.set_mode((600, 360))
        clock = pygame.time.Clock()

        for _ in range(120):
            screen.fill((30, 30, 30))

            # Top bar
            pygame.draw.rect(screen, (45, 45, 48), (0, 0, 600, 40))
            # Left panel
            pygame.draw.rect(screen, (37, 37, 38), (0, 40, 160, 320))
            # Content
            pygame.draw.rect(screen, (30, 30, 30), (160, 40, 440, 320))

            pygame.display.flip()
            clock.tick(30)
            time.sleep(0.01)

    if __name__ == "__main__":
        main()


 
 
===========================================
8. IMAGE HANDLING & SCREENSHOT BACKGROUNDS
===========================================

There are two common ways images can exist in your environment:

- As **raw binary files** (actual `.png` bytes, e.g., from a zip project).
- As **Data URL text files** (imported via the IDE’s image import).

8.1 Detecting the image format from Python

    def detect_image_type(path="screenshot.png"):
        with open(path, "rb") as f:
            head = f.read(32)
        if head.startswith(b"data:image"):
            return "data-url"
        if head.startswith(b"\x89PNG\r\n\x1a\n"):
            return "png-binary"
        return "unknown"

    print(detect_image_type())

Use this to decide which loading strategy to use.

-------------------------------------------
8.2 VDG window background from a Data URL file
-------------------------------------------

Case: `screenshot.png` is a **text file containing a Data URL** like
`data:image/png;base64,...`.

    import js
    from js import document

    def main():
        # 1) Read Data URL from the virtual filesystem
        with open("screenshot.png", "r", encoding="utf-8") as f:
            data_url = f.read().strip()

        # 2) Create a JS Image object
        Image = js.Image
        img = Image.new()
        img.src = data_url

        # 3) Create a VDG window
        js_bridge = js.window.js_bridge
        win = js_bridge.create_window("Screenshot Background (Data URL)", 800, 600)

        win_el = document.getElementById(win.id)
        canvas = win_el.querySelector("canvas")
        ctx = canvas.getContext("2d")

        def draw(*_args):
            w = int(canvas.width)
            h = int(canvas.height)
            if w <= 0 or h <= 0:
                return
            ctx.clearRect(0, 0, w, h)
            ctx.drawImage(img, 0, 0, w, h)

        from pyodide.ffi import create_proxy
        draw_proxy = create_proxy(draw)
        js.window._screenshot_draw_proxy = draw_proxy

        js.window.setInterval(draw_proxy, 200)
        print("Screenshot background window (Data URL) running.")

    main()


 
-------------------------------------------
8.3 VDG window background from a binary PNG file
-------------------------------------------

Case: `screenshot.png` is **real PNG bytes**.

    import base64
    import js
    from js import document
    from pyodide.ffi import create_proxy

    _draw_proxy = None
    _onload_proxy = None

    def main():
        log_debug = js.window.logDebug

        # 1) Load screenshot.png as binary
        try:
            with open("screenshot.png", "rb") as f:
                data = f.read()
            log_debug("Loaded screenshot.png (binary)", "success")
        except Exception as e:
            log_debug(f"Failed to load screenshot.png: {e}", "error")
            print("Failed to load screenshot.png:", e)
            return

        # 2) Convert to Data URL
        try:
            data_b64 = base64.b64encode(data).decode("ascii")
            data_url = "data:image/png;base64," + data_b64
            log_debug("Converted screenshot.png to data URL", "info")
        except Exception as e:
            log_debug(f"Failed to convert image to data URL: {e}", "error")
            print("Failed to convert image to data URL:", e)
            return

        # 3) Create JS Image
        try:
            Image = js.Image
            img = Image.new()
            img.src = data_url
            log_debug("Created JS Image and set src", "info")
        except Exception as e:
            log_debug(f"Failed to create JS Image: {e}", "error")
            print("Failed to create JS Image:", e)
            return

        # 4) Create VDG window
        try:
            js_bridge = js.window.js_bridge
            win = js_bridge.create_window("Screenshot Background", 800, 600)
            log_debug(f"Created VDG window with id={win.id}", "success")
        except Exception as e:
            log_debug(f"Failed to create VDG window: {e}", "error")
            print("Failed to create VDG window:", e)
            return

        # 5) Get canvas/context
        try:
            win_el = document.getElementById(win.id)
            if not win_el:
                log_debug("VDG window element not found in DOM", "error")
                return

            canvas = win_el.querySelector("canvas")
            if not canvas:
                log_debug("Canvas not found inside VDG window", "error")
                return

            ctx = canvas.getContext("2d")
            if not ctx:
                log_debug("Failed to get 2D context from canvas", "error")
                return

            log_debug(f"Canvas initial size: {canvas.width}x{canvas.height}", "info")
        except Exception as e:
            log_debug(f"Error while getting canvas/context: {e}", "error")
            print("Error while getting canvas/context:", e)
            return

        state = {"loaded": False}

        def on_load(event):
            state["loaded"] = True
            log_debug("Image load event fired", "success")

        global _onload_proxy
        _onload_proxy = create_proxy(on_load)
        img.addEventListener("load", _onload_proxy)

        def draw(*_args):
            if not state["loaded"]:
                return
            w = int(canvas.width)
            h = int(canvas.height)
            if w <= 0 or h <= 0:
                return
            ctx.clearRect(0, 0, w, h)
            ctx.drawImage(img, 0, 0, w, h)

        global _draw_proxy
        _draw_proxy = create_proxy(draw)
        js.window.setInterval(_draw_proxy, 200)
        log_debug("Started screenshot draw interval (200ms)", "info")

    main()


 
 
===========================================
9. STRUCTURING APPS & BEST PRACTICES
===========================================

9.1 State + draw() pattern

Most apps should:

1. Keep a `state` dict (world / UI state).
2. Have a `draw()` function that renders the screen from `state`.
3. Input handlers change `state`, then call `draw()`.

Example skeleton:

    import js
    from pyodide.ffi import create_proxy

    WIDTH, HEIGHT = 400, 300
    _key_proxy = None

    def main():
        js_bridge = js.window.js_bridge
        win = js_bridge.create_window("App Skeleton", WIDTH, HEIGHT)

        state = {
            "message": "Hello",
            "counter": 0,
        }

        def draw():
            win.clear()
            win.fill_rect(0, 0, WIDTH, HEIGHT, "#101010")
            win.draw_text(10, 40, state["message"], "white", "18px Arial")
            win.draw_text(10, 80, f"Counter: {state['counter']}", "cyan", "16px monospace")

        def on_key_down(event):
            if event.key in (" ", "Spacebar"):
                state["counter"] += 1
                draw()

        global _key_proxy
        _key_proxy = create_proxy(on_key_down)
        js.document.addEventListener("keydown", _key_proxy)
        js.window._app_skeleton_proxy = _key_proxy

        draw()
        print("App skeleton ready, press space to increment counter.")

    main()


 
9.2 Proxies and cleanup checklist

- Every function you pass into JS (event listeners, timers) must be:
  - Wrapped with `create_proxy`.
  - Stored somewhere live (e.g. `js.window._my_proxy = proxy`).
- When you stop using it, also:
  - Clear intervals with `js.window.clearInterval(id)`.
  - Remove event listeners with `removeEventListener`.
  - Optionally delete stored proxies from `js.window`.

Example cleanup snippet:

    def cleanup():
        try:
            js.window.clearInterval(interval_id)
        except Exception:
            pass
        try:
            js.document.removeEventListener("keydown", key_proxy)
        except Exception:
            pass
        try:
            del js.window._my_proxies
        except Exception:
            pass


 
9.3 Printing to IDE console from helper modules

From any function, you can:

    js_bridge = js.window.js_bridge
    js_bridge.print_to_console("Hello from my engine!")

This writes directly to the IDE Terminal.


 
 
===========================================
END OF syntax_v2.syn
===========================================
